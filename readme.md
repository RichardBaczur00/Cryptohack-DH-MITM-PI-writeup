# Cryptohack DH Algorithm Write-up
## Parameter injection (MITM attack)
### Short description
In this challenge we are presented with a socket, we're we are told that Bob and Alice are communicating with each other. We are also told that we can influence their key exchange, which makes the problem a lot simpler. We are also given a netcat socket and port ```nc socket.cryptohack.org 13371``` 
### First observations
We first try to connect to the socket through netcat in the terminal and see that the communication takes place like this: Alice sends p(the modulo), g(the base, or generator) and A(Alice's public key) to Bob. For testing purposes I decided to just forward the payload to Bob without changing anything. Bob responds with B(his public key) and then Alice sends the encrypted flag with an IV(Initialization vector)
### Exploits
After presenting the problem and the communication process, I think I can start discussing strategy. The problem is using a key exchange method called the Diffie-Hellman key exchange. This algorithm follows a few simple mathematical formulas to create a pretty solid shared secret key. But, the more someone knows and more importantly, can influence, the worse this key exchange becomes. From Alice's first payload we receive p, g and A(meanings discussed above). At first, I didn't see much in these values. But the it clicked, I could just forward the payload to Bob and operate on Bob's payload. So I've decided to create my own secret key and shared secret with Alice, completely eliminating Bob from the equation. After receiving Bob's public key, I've replaced it with my public key and created my shared secret using Alice's public leu and my private key. After doing this, I received the payload that contained the IV and the encrypted flag. Now all I had to do was decrypt it.
### Decrypting the flag
The encryption on the flag is a standard AES CBC ciphertext. They key is the shared secret we have found using the method mentioned above. The shared secret must be processed with a sha1 digest. We use AES from Crypto.Cipher to create a key and decrypt the flag. In case the flag is also padded, we unpad it. If it ain't, then we just decode it to ascii and print it.